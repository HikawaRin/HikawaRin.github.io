<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hikawarin.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="BST(Binary Search Tree) is a widely used data structure, which can reduce the time complex of opration to average \(O(log n)\). Many problem can be efficient solved with BST, e.g. whether an element">
<meta property="og:type" content="article">
<meta property="og:title" content="Binary Search Tree">
<meta property="og:url" content="http://hikawarin.github.io/2022/07/18/Binary-Search-Tree/index.html">
<meta property="og:site_name" content="Blue Period">
<meta property="og:description" content="BST(Binary Search Tree) is a widely used data structure, which can reduce the time complex of opration to average \(O(log n)\). Many problem can be efficient solved with BST, e.g. whether an element">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://hikawarin.github.io/images/Binary_Search_Tree/bst.svg">
<meta property="article:published_time" content="2022-07-18T21:59:38.000Z">
<meta property="article:modified_time" content="2022-07-23T07:22:42.390Z">
<meta property="article:author" content="Hikawa Rin">
<meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hikawarin.github.io/images/Binary_Search_Tree/bst.svg">


<link rel="canonical" href="http://hikawarin.github.io/2022/07/18/Binary-Search-Tree/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://hikawarin.github.io/2022/07/18/Binary-Search-Tree/","path":"2022/07/18/Binary-Search-Tree/","title":"Binary Search Tree"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Binary Search Tree | Blue Period</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Blue Period</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Personal blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">3</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">3</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#definition"><span class="nav-number">1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#impementation"><span class="nav-number">2.</span> <span class="nav-text">Impementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#node-structure"><span class="nav-number">2.1.</span> <span class="nav-text">Node Structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#query-key"><span class="nav-number">2.2.</span> <span class="nav-text">Query Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-number">2.3.</span> <span class="nav-text">Insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete"><span class="nav-number">2.4.</span> <span class="nav-text">Delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-rank"><span class="nav-number">2.5.</span> <span class="nav-text">Find Rank</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-node-with-rank"><span class="nav-number">2.6.</span> <span class="nav-text">Find node with rank</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-previous-and-successor"><span class="nav-number">2.7.</span> <span class="nav-text">Get Previous and Successor</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hikawa Rin"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hikawa Rin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/HikawaRin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hikawarin.github.io/2022/07/18/Binary-Search-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hikawa Rin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue Period">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Binary Search Tree | Blue Period">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Binary Search Tree
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-18 21:59:38" itemprop="dateCreated datePublished" datetime="2022-07-18T21:59:38+00:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-23 07:22:42" itemprop="dateModified" datetime="2022-07-23T07:22:42+00:00">2022-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Data-Structure/" itemprop="url" rel="index"><span itemprop="name">Data Structure</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Data-Structure/Binary-Search-Tree-Balance-Tree/" itemprop="url" rel="index"><span itemprop="name">Binary Search Tree & Balance Tree</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>  BST(Binary Search Tree) is a widely used data structure, which can reduce the time complex of opration to average <span class="math inline">\(O(log n)\)</span>. Many problem can be efficient solved with BST, e.g. whether an element existed, find the N-th biggest/smallest element, etc. We can implement other data structure with BST, such as set, map. <span id="more"></span></p>
<h2 id="definition">Definition</h2>
<p>  BST is a binary tree data structure which has the following properties:<br />
- An empty tree is a BST.<br />
- The left subtree of root node is a BST and <strong>all</strong> nodes in subtrer <strong>less</strong> than root.<br />
- The right subtree of root is also a BST and <strong>all</strong> nodes in subtree <strong>greater</strong> than root.</p>
<p>  A BST may look like below: <img src="/images/Binary_Search_Tree/bst.svg" alt="BST" /></p>
<h2 id="impementation">Impementation</h2>
<p>  Here I post my implementation of BST, the complete code can be find <a target="_blank" rel="noopener" href="https://github.com/HikawaRin/data_structure/blob/master/binary_search_tree_and_balanced_tree/binary_search_tree.cc">here</a></p>
<h3 id="node-structure">Node Structure</h3>
<p>  The tree node structure defined as below: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; </span><br><span class="line">  <span class="type">int</span> e[<span class="number">3</span>]; <span class="comment">// Store the index of left son, right son and parent</span></span><br><span class="line">  <span class="type">int</span> key; <span class="comment">// The key of that node</span></span><br><span class="line">  <span class="type">int</span> cnt; <span class="comment">// The number of duplicate key</span></span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// The number of nodes contains in this subtree</span></span><br><span class="line">&#125;nodes[tree_size];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> node_cnt&#123;<span class="number">1</span>&#125;; <span class="comment">// The index of unused node, 0 reference to NULL node</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> root&#123;<span class="number">0</span>&#125;; <span class="comment">// The root of bst, initial to not exist</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Help function</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">ls</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> &amp;(nodes[n].e[<span class="number">0</span>]); &#125; <span class="comment">// Get left son</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">rs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> &amp;(nodes[n].e[<span class="number">1</span>]); &#125; <span class="comment">// Get right son</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> &amp;(nodes[n].e[<span class="number">2</span>]); &#125; <span class="comment">// Get parent</span></span><br></pre></td></tr></table></figure>   Notice that we stored the parent index in each node, that would be very useful in delete and range search.</p>
<h3 id="query-key">Query Key</h3>
<p>  Query a key in BST is just like binary search. We start at BST root, if key smaller than root key, we let the left son of root be the new root; else if key greater than root key, we let the right son be the new root. Recursive the step above until we find the key or reached null node.<br />
  Here`s the code: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> it = root;</span><br><span class="line">  <span class="keyword">while</span> (it != <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="type">int</span> cmp = key - nodes[it].key;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; it = *<span class="built_in">ls</span>(it); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; it = *<span class="built_in">rs</span>(it); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="insert">Insert</h3>
<p>  Each time we insert a key into BST we need first query the key, if node with that key exist, we simply increase it`s count; Otherwise we need construct a new node with that key and set it to the proper position.<br />
  With the help of pointer, we can perform insert in <strong>one pass</strong>.<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> *ip = &amp;root, pa = <span class="number">0</span>; <span class="comment">// we can update new node`s index in BST with the help of pointer</span></span><br><span class="line">  <span class="keyword">while</span> (*ip != <span class="number">0</span>) &#123; </span><br><span class="line">    ++nodes[*ip].size; <span class="comment">// each insert would increase the subtree size by 1</span></span><br><span class="line">    <span class="comment">// travel the BST, update iterator and parent info</span></span><br><span class="line">    <span class="type">int</span> cmp = key - nodes[*ip].key;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; pa = *ip; ip = <span class="built_in">ls</span>(pa); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; pa = *ip; ip = <span class="built_in">rs</span>(pa); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// duplicate key, increase the node counter</span></span><br><span class="line">      ++nodes[*ip].cnt; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// now the ip pointer to null node, but ip itself is the last node`s e[0]/e[1], </span></span><br><span class="line">  <span class="comment">// which need hold our new node`s index</span></span><br><span class="line">  *ip = node_cnt++; <span class="comment">// fetch an unused index</span></span><br><span class="line">  <span class="comment">// Update node information</span></span><br><span class="line">  nodes[*ip].key = key; nodes[*ip].cnt = <span class="number">1</span>; nodes[*ip].size = <span class="number">1</span>;</span><br><span class="line">  *<span class="built_in">p</span>(*ip) = pa; *<span class="built_in">ls</span>(*ip) = <span class="number">0</span>; *<span class="built_in">rs</span>(*ip) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="delete">Delete</h3>
<p>  Similar to insert, first we need to locate the node, which hold the key. If the counter greater than 1, we just decrease the counter. But if the counter become 0, we need perform a node delete, and there are three case:<br />
1. the node is a leaf<br />
just delete it.<br />
2. one son of the node is null<br />
replace that node with the not null son, then delete it. 3. Both son of the node is not null<br />
In this scenario we can not delete that node without broken BST. We will need the remove successor strategy, which find the successor of the node, swap node information and delete the successor node.<br />
Why it works, because in BST the left son of successor must be null, if it`s not null, then the left son will be the really successor.<br />
Let`s take a look at code, I assume the key to delete exist in BST: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> *ip = &amp;root; <span class="comment">// Again make our life easier with pointer</span></span><br><span class="line">  <span class="keyword">while</span> (*ip != <span class="number">0</span>) &#123; </span><br><span class="line">    --nodes[*ip].size; <span class="comment">// the subtree would decrease by 1</span></span><br><span class="line">    <span class="type">int</span> cmp = key - nodes[*ip].key;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; ip = <span class="built_in">ls</span>(*ip); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; ip = <span class="built_in">rs</span>(*ip); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; --nodes[*ip].cnt; <span class="keyword">break</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nodes[*ip].cnt == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// need remove node</span></span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">ls</span>(*ip) == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// left son is null</span></span><br><span class="line">      <span class="keyword">if</span> (*<span class="built_in">rs</span>(*ip) != <span class="number">0</span>) &#123; *<span class="built_in">p</span>(*<span class="built_in">rs</span>(*ip)) = *<span class="built_in">p</span>(*ip); &#125;</span><br><span class="line"></span><br><span class="line">      *ip = *<span class="built_in">rs</span>(*ip); <span class="comment">// like insert, ip is the parent node`s e[0]/e[1]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">rs</span>(*ip) == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// right son is null</span></span><br><span class="line">      *<span class="built_in">p</span>(*<span class="built_in">ls</span>(*ip)) = *<span class="built_in">p</span>(*ip);</span><br><span class="line"></span><br><span class="line">      *ip = *<span class="built_in">ls</span>(*ip); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// Third case</span></span><br><span class="line">      <span class="comment">// find successor</span></span><br><span class="line">      <span class="type">int</span> *sip = <span class="built_in">rs</span>(*ip);</span><br><span class="line">      <span class="keyword">while</span> (*<span class="built_in">ls</span>(*sip) != <span class="number">0</span>) &#123; sip = <span class="built_in">ls</span>(*sip); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// swap information</span></span><br><span class="line">      nodes[*ip].key = nodes[*sip].key; nodes[*ip].cnt = nodes[*ip].cnt;</span><br><span class="line">      <span class="comment">// decrease subtree by successor counter</span></span><br><span class="line">      ip = <span class="built_in">rs</span>(*ip);</span><br><span class="line">      <span class="keyword">while</span> (ip != sip) &#123; nodes[*ip].size -= nodes[*sip].cnt; ip = <span class="built_in">ls</span>(*ip); &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (*<span class="built_in">rs</span>(*ip) != <span class="number">0</span>) &#123; *<span class="built_in">p</span>(*<span class="built_in">rs</span>(*ip)) = *<span class="built_in">p</span>(*ip); &#125;</span><br><span class="line">      *ip = *<span class="built_in">rs</span>(*ip);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> With the help of pointer and parent information, we can remove node in <strong>one pass</strong>, just like doubly linked list.</p>
<h3 id="find-rank">Find Rank</h3>
<p>If key greater than node key, the left subtree must have lower rank, so add up left subtree`s size to rank. This method works even the key not exist in BST. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_rank</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> rank = <span class="number">1</span>, it = root;</span><br><span class="line">  <span class="keyword">while</span> (it != <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="type">int</span> cmp = key - nodes[it].key;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; </span><br><span class="line">      rank += (nodes[*<span class="built_in">ls</span>(it)].size + nodes[it].cnt);</span><br><span class="line">      it = *<span class="built_in">rs</span>(it); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; it = *<span class="built_in">ls</span>(it); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-node-with-rank">Find node with rank</h3>
<p>If left subtree`s size smaller than rank, than rank cannot be in left subtree, decrease rank by the size of left subtree. If rank in root, it cannot greater than root node counter now. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> it = root;</span><br><span class="line">  <span class="keyword">while</span> (it != <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (rank &gt; nodes[*<span class="built_in">ls</span>(it)].size) &#123; </span><br><span class="line">      rank -= (nodes[*<span class="built_in">ls</span>(it)].size + nodes[it].cnt);</span><br><span class="line">      <span class="keyword">if</span> (rank &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> it; &#125;</span><br><span class="line">      it = *<span class="built_in">rs</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; it = *<span class="built_in">ls</span>(it); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// rank bigger than BST size, interrupt directly</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="get-previous-and-successor">Get Previous and Successor</h3>
<p>We can use parent information to find the previous or successor. But there already exist a silver bullet. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Previous</span></span><br><span class="line"><span class="comment">// the query_rank will ignore the duplicate key, so decrease it by 1 to get the previous key rank</span></span><br><span class="line"><span class="comment">// query that rank we can get the previous node</span></span><br><span class="line">nodes[<span class="built_in">query</span>(<span class="built_in">query_rank</span>(key)<span class="number">-1</span>)].key;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Successor</span></span><br><span class="line"><span class="comment">// Simillar to previous, this time we first take the rank of (key + 1) that will return the rank of successor node </span></span><br><span class="line"><span class="comment">// query that rank we can get the successor node</span></span><br><span class="line">nodes[<span class="built_in">query</span>(<span class="built_in">query_rank</span>(key+<span class="number">1</span>))].key;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Data-Structure/" rel="tag"># Data Structure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/14/setup-blog/" rel="prev" title="Build up your personal Blog with Hexo and Github-Pages">
                  <i class="fa fa-chevron-left"></i> Build up your personal Blog with Hexo and Github-Pages
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/21/Red-Black-Tree/" rel="next" title="Red Black Tree">
                  Red Black Tree <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hikawa Rin</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Symbols count total: </span>
    <span title="Symbols count total">13k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">9 mins.</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
